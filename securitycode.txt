1. Write a program to implement breadth first search algorithm.

from collections import deque
# Define the graph
graph1 = {
    'A': set(['B', 'C']),
    'B': set(['A', 'D', 'E']),
    'C': set(['A', 'F']),
    'D': set(['B']),
    'E': set(['B', 'F']),
    'F': set(['C', 'E'])
}
# Define the BFS function
def bfs(graph, start_node):
    visited = []
    queue = deque([start_node])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.append(node)
            queue.extend(graph[node] - set(visited))
    return visited
# Perform BFS starting from node 'A'
visited_bfs = bfs(graph1, 'A')
print("Result of BFS:", visited_bfs)


2. Write a program to implement depth first search algorithm.

graph1 = {
'A': set(['B', 'C']),
'B': set(['A', 'D', 'E']),
'C': set(['A', 'F']),
'D': set(['B']),
'E': set(['B', 'F']),
'F': set(['C', 'E'])
}


def dfs(graph, node, visited):
  if node not in visited:
    visited.append(node)
    for n in graph[node]:
      dfs(graph,n, visited)
    return visited
visited = dfs(graph1,'A', [])
print("Result of DFS:" , visited)


3. Write a program to solve the tower of Hanoi problem.

def tower_of_hanoi(n, source, auxiliary, target):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
        return
    tower_of_hanoi(n-1, source, target, auxiliary)
    print(f"Move disk {n} from {source} to {target}")
    tower_of_hanoi(n-1, auxiliary, source, target)
n = 3
tower_of_hanoi(n, 'A', 'B', 'C')

4. Write a program to implement A* algorithm.

pip install simpleai

pip install pydot flask

main.code

from simpleai.search import SearchProblem, astar
GOAL = 'HELLO WORLD'
class HelloProblem(SearchProblem):
  def actions(self, state):
    if len(state) < len(GOAL):
      return list(' ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    else:
      return []
  def result(self, state, action):
    return state + action
  def is_goal(self, state):
    return state == GOAL
  def heuristic(self, state):
 # how far are we from the goal?
    wrong = sum([1 if state[i] != GOAL[i] else 0
    for i in range(len(state))])
    missing = len(GOAL) - len(state)
    return wrong + missing
problem = HelloProblem(initial_state='')
result = astar(problem)
print(result.state)
print(result.path())

5. Write a program to solve constraint satisfaction problem.

pip install simpleai

main.code

from __future__ import print_function
from simpleai.search import CspProblem, backtrack, min_conflicts,MOST_CONSTRAINED_VARIABLE, HIGHEST_DEGREE_VARIABLE,LEAST_CONSTRAINING_VALUE
variables = ('WA', 'NT', 'SA', 'Q', 'NSW', 'V', 'T')
domains = dict((v, ['red', 'green', 'blue']) for v in variables)
def const_different(variables, values):
    return values[0] != values[1] # expect the value of the neighbors to be different
constraints = [
 (('WA', 'NT'), const_different),
 (('WA', 'SA'), const_different),
 (('SA', 'NT'), const_different),
 (('SA', 'Q'), const_different),
 (('NT', 'Q'), const_different),
 (('SA', 'NSW'), const_different),
 (('Q', 'NSW'), const_different),
 (('SA', 'V'), const_different),
 (('NSW', 'V'), const_different),
]
my_problem = CspProblem(variables, domains, constraints)
print(backtrack(my_problem))
print(backtrack(my_problem,
variable_heuristic=MOST_CONSTRAINED_VARIABLE))
print(backtrack(my_problem,
variable_heuristic=HIGHEST_DEGREE_VARIABLE))
print(backtrack(my_problem,
value_heuristic=LEAST_CONSTRAINING_VALUE))
print(backtrack(my_problem,
variable_heuristic=MOST_CONSTRAINED_VARIABLE,
value_heuristic=LEAST_CONSTRAINING_VALUE))
print(backtrack(my_problem,
variable_heuristic=HIGHEST_DEGREE_VARIABLE,
value_heuristic=LEAST_CONSTRAINING_VALUE))
print(min_conflicts(my_problem))

6. Write a program to implement alpha-beta search.

tree = [[[5, 1, 2], [8, -8, -9]], [[9, 4, 5], [-3, 4, 3]]]
root = 0
pruned = 0
def children(branch, depth, alpha, beta):
  global tree
  global root
  global pruned
  i = 0
  for child in branch:
    if type(child) is list:
      (nalpha, nbeta) = children(child, depth + 1, alpha, beta)
      if depth % 2 == 1:
        beta = nalpha if nalpha < beta else beta
      else:
        alpha = nbeta if nbeta > alpha else alpha
      branch[i] = alpha if depth % 2 == 0 else beta
      i += 1
    else:
      if depth % 2 == 0 and alpha < child:
        alpha = child
      if depth % 2 == 1 and beta > child:
        beta = child
      if alpha >= beta:
        pruned += 1
        break
  if depth == root:
    tree = alpha if root == 0 else beta
  return (alpha, beta)
def alphabeta(in_tree=tree, start=root, upper=-15, lower=15):
  global tree
  global pruned
  global root
  (alpha, beta) = children(tree, start, upper, lower)

  if __name__ == "__main__":
    print ("(alpha, beta): ", alpha, beta)
    print ("Result: ", tree)
    print ("Times pruned: ", pruned)
  return (alpha, beta, tree, pruned)
if __name__ == "__main__":
  alphabeta(None)

7. Write a program to simulate 4-Queen/N-Queen problem.

def is_safe(board, row, col):
    # Check this row on the left side
    for i in range(col):
        if board[row][i] == 1:
            return False
    # Check upper diagonal on the left side
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    # Check lower diagonal on the left side
    for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    return True
def solve_nqueens(board, col, solutions):
    # Base case: If all queens are placed, add the solution
    if col >= len(board):
        solutions.append([row[:] for row in board])
        return
    # Consider this column and try placing the queen in all rows one by one
    for i in range(len(board)):
        if is_safe(board, i, col):
            # Place this queen in board[i][col]
            board[i][col] = 1
            # Recur to place the rest of the queens
            solve_nqueens(board, col + 1, solutions)
            # If placing queen in board[i][col] doesn't lead to a solution, remove the queen
            board[i][col] = 0
def print_solution(board):
    for row in board:
        print(" ".join("Q" if cell else "." for cell in row))
    print()
def solve_4queens():
    board = [[0 for _ in range(4)] for _ in range(4)]
    solutions = []
    solve_nqueens(board, 0, solutions)
    if not solutions:
        print("Solution does not exist")
    else:
        print(f"Found {len(solutions)} solutions:")
        for solution in solutions:
            print_solution(solution)
# Solve the 4-Queens problem
solve_4queens()

8. Write a program to derive the predicate. (For e.g.: Sachin is batsman, batsman is
cricketer) -> Sachin is Cricketer

def derive_predicate(statements, subject):
    predicate_map = {}

    for statement in statements:
        parts = statement.split(" is a ")
        predicate_map[parts[0]] = parts[1]

    current_subject = subject
    while current_subject in predicate_map:
        current_subject = predicate_map[current_subject]

    return f"{subject} is a {current_subject}"

# Example usage
statements = [
    "Sachin is a batsman",
    "batsman is a cricketer"
]

subject = "Sachin"
result = derive_predicate(statements, subject)
print(result)

9. Write a program to solve water jug problem.

# 3 water jugs capacity -> (x,y,z) where x>y>z
# initial state (12,0,0)
# final state (6,6,0)
capacity = (12,8,5)
# Maximum capacities of 3 jugs -> x,y,z
x = capacity[0]
y = capacity[1]
z = capacity[2]
# to mark visited states
memory = {}
# store solution path
ans = []

def get_all_states(state):
    # Let the 3 jugs be called a, b, c
    a = state[0]
    b = state[1]
    c = state[2]

    if (a == 6 and b == 6):
        ans.append(state)
        return True

    # if current state is already visited earlier
    if (state in memory):
        return False

    memory[state] = 1

    # empty jug a
    if (a > 0):
        # empty a into b
        if (a + b <= y):
            if (get_all_states((0, a + b, c))):
                ans.append(state)
                return True
        else:
            if (get_all_states((a - (y - b), y, c))):
                ans.append(state)
                return True

        # empty a into c
        if (a + c <= z):
            if (get_all_states((0, b, a + c))):
                ans.append(state)
                return True
        else:
            if (get_all_states((a - (z - c), b, z))):
                ans.append(state)
                return True

    # empty jug b
    if (b > 0):
        # empty b into a
        if (a + b <= x):
            if (get_all_states((a + b, 0, c))):
                ans.append(state)
                return True
        else:
            if (get_all_states((x, b - (x - a), c))):
                ans.append(state)
                return True

        # empty b into c
        if (b + c <= z):
            if (get_all_states((a, 0, b + c))):
                ans.append(state)
                return True
        else:
            if (get_all_states((a, b - (z - c), z))):
                ans.append(state)
                return True

    # empty jug c
    if (c > 0):
        # empty c into a
        if (a + c <= x):
            if (get_all_states((a + c, b, 0))):
                ans.append(state)
                return True
        else:
            if (get_all_states((x, b, c - (x - a)))):
                ans.append(state)
                return True

        # empty c into b
        if (b + c <= y):
            if (get_all_states((a, b + c, 0))):
                ans.append(state)
                return True
        else:
            if (get_all_states((a, y, c - (y - b)))):
                ans.append(state)
                return True

    return False

initial_state = (12, 0, 0)
print("Starting work...\n")
get_all_states(initial_state)
ans.reverse()
for i in ans:
    print(i)

